.. _intro_m_layer: 

############
Introduction
############

.. contents::
   :local:

Why is the M-layer needed?
==========================
The M-layer provides a framework to support digital representations of measured data. It offers representations that can be interpreted without ambiguity, thus enabling reuse and interoperability of data. The scope is broad, because of the variety of types of measurement data. The M-layer uses several basic notions from measurement science to handle a variety of types of measurement data. The need to implement these notions can be seen by looking at a few of the difficulties that arise when using the *International System of Units* (SI).

Many SI unit names may be intuitively associated with a particular type of quantity (like the kilogram and the metre, which are used as units of mass and length, respectively). So, we become used to thinking that the name of a unit will identify the quantity. However, that is not always correct. The same unit may sometimes be used to express quite different quantities. The most obvious example being all the quantities expressed in terms of the SI unit 'one' (quantities of dimension one, or 'dimensionless' quantities, like aspect ratio, reflectance, refractive index, etc.).

There are also problems with the units for temperature in the SI. You can legitimately express a temperature in kelvin or degrees Celsius. However, conversion of a temperature between kelvin and degrees Celsius involves two operations: addition and multiplication. No other SI units behave this way under conversion. Furthermore, a temperature difference can be expressed in the same units, kelvin or degrees Celsius, which is problematic because conversion of temperature differences between kelvin and degrees Celsius *only* involves multiplication (by a conversion factor). So, the method of conversion is different for a temperature or a temperature difference, but you cannot identify the quantity from the units alone.  

Another difficulty occurs with plane angles. The special name of the SI unit for angle is radian, but the range of values is not specified. Sometimes the range of values extends from :math:`-\pi` to :math:`+\pi`, and sometimes from :math:`0` to :math:`2\pi`, while in other cases there are no limits. This circular, or cyclic, structure of data is quite different from any other SI unit.

These examples are exceptional cases for the SI, but they do illustrate properties of measurement data that cannot be supported by the SI format. The M-layer can address these difficulties, and, in doing so, provides support for a wider range of measurement data.  

What is the M-layer?
====================

A quantity is traditionally expressed by pairing a number with the name, or symbol, for a unit, like 10 kg. However, people need to use contextual information to interpret these expressions. Digital systems are not as good as people at handling ambiguity, so the M-layer provides a more detailed framework. It does this by taking into account: 

    * the type of scale being used (relates to conversion operations)
    * the nature of what is being expressed (mass, temperature, angle, etc.)
    
The first point is handled by extending the traditional notion of a unit (or reference). The M-layer uses an entity called a *scale* to associate a unit (or reference) with a type of scale. These scales can overcome the sort of ambiguity caused, for example, by allowing the unit degree Celsius to express both temperature and temperature difference.

The second point is handled by explicitly recognising different kinds of quantity in a component called *aspect*. The meaning of aspect is similar to, but broader than, the term 'kind of quantity', as used with SI units.
   
M-layer identifiers 
-------------------
   
The M-layer maintains a register of information about aspects and scales. Client software deals with objects that index these M-layer records. 

In the example below, convenient Python names are used to refer to ``Aspect`` and ``Scale`` objects (``kg``, etc.) that encapsulate M-layer identifiers. The tuple that initialises these objects has two elements: a name, and a universal unique identifier (UUID) in integer format. The name is intended to help people recognise objects.  

Example
-------
The script below generates an expression of 12 kg and then converts it to the Imperial unit pounds. 

The function ``display()`` outputs the short (``str``) and long (``repr``) string representations of an expression.

Initially, local names are defined for aspect and scale objects (``mass``, ``kg``, and ``lb``), which are initialised by M-layer identifiers. 

An expression for ``x`` is generated by combining the value 12 with the ``kg`` scale and the ``mass`` aspect. The expression ``x`` may be converted to an expression in Imperial pounds. ::

    >>> from m_layer import *
    
    >>> def display(xp):
    ...    print(xp)       # String format
    ...    print(repr(xp)) # Representation format
    ...    print()

    >>> mass = Aspect( ('ml_mass',321881801928222308627062904049725548287) )
    >>> kg = Scale( ('ml_si_kilogram_ratio',12782167041499057092439851237297548539) )
    >>> lb = Scale( ('ml_imp_pound_ratio',188380796861507506602975683857494523991) )
    
    >>> x = expr(12,kg,mass)
    >>> display(x)
    12 kg
    Expression(12,kg,mass)
    <BLANKLINE>
    >>> display(x.convert(lb))
    26.4552 lb
    Expression(26.4552,lb,mass)
    <BLANKLINE>
    
It is worth noting that aspect is not a mandatory component. So, the example above could be handled in this way:: 

    >>> y = expr(12,kg)
    >>> display(y)
    12 kg
    Expression(12,kg)
    <BLANKLINE>
    >>> display(y.convert(lb))
    26.4552 lb
    Expression(26.4552,lb)
    <BLANKLINE>
    
A scale alone may be considered sufficient to express a magnitude (as it is with standard SI formats). However, an aspect is usually needed to adequately represent a wider range of measurement data and to handle special cases that arise in the SI (aspect is never inferred from the scale provided). 