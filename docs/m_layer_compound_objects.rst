.. _concept_m_compound_objects: 

==================================
Arithmetic with scales and aspects
==================================

.. contents::
   :local:

Unit composition is often a useful way to express measured quantities, and is supported in m-layer-concept. 

.. note::

    There is a widely-held belief that units of measurement can be generated by multiplying other units together. This is a misunderstanding.  
    Another widely-held belief is that the rules of quantity calculus can be applied to measurement data expressed in any format. 
    This is also a misunderstanding.  

The problem with unit arithmetic 
================================

Unit multiplication is sensible when unit names are treated as conversion factor variables. For example, a speed expressed as 50 km/h, may be converted to 13.89 m/s by knowing that kg = 1000 m and h = 3600 s. The unit names, km/h and m/s, encode the dimensions of speed, L/T; they describe a formula for a unit conversion factor. However, software struggles to deal with situations where the dimensions of a compound unit expression can be associated with several different units of measurement (e.g., the fact that kg m2 s-2 may be considered as a unit for torque or as a unit for work or energy). Additional information is needed to specify the correct unit in such cases. 

Compound scales 
===============

Terminology: 'systematic' names
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

The term systematic is used in m-layer-concept to describe unit names that are composed from products of powers of base unit names or symbols in a unit system (or prefixed base unit names). For example, kilogram metre squared per second squared (kg.m2.s-2) is a systematic unit name in the SI. 

Speed
~~~~~

Speed provides a simple example of how m-layer-concept handles compound units. 

We first import the package and declare scales for length and time ::

    >>> from m_layer import *
    
    >>> m = Scale( ('ml_si_metre_ratio', 17771593641054934856197983478245767638) )
    >>> s = Scale( ('ml_si_second_ratio', 276296348539283398608930897564542275037) )
    
A compound unit for speed can then be generated and used in an expression ::

    >>> m_s = m/s 
    >>> print( m_s ) 
    m/(s)
    >>> v = expr(1.5, m/s )
    >>> print( v )
    1.5 m/(s)
    
Alternative compound units for speed can be created using different scales for length and time ::

    >>> ft = Scale( ('ml_foot_ratio', 150280610960339969789551668292960104920) )
    >>> minute = Scale( ('ml_si_minute_ratio', 219754916679293138667106941253484129447 ) )
    <BLANKLINE>
    >>> ft_min = ft/minute 
    >>> print( ft_min ) 
    ft/(min)
    
Conversion is possible (but the arithmetic expressions defining the compound scales must have exactly the same form) ::

    >>> print( v.convert( ft_min ) )
    295.2756 ft/(min)
    
Note, the compound-scale objects shown above are not automatically resolved to a single M-layer scale for speed. However, when a corresponding scale is available, a compound scale can be converted. In this example, there is an m-layer-concept scale defined for speed, so conversion can be carried out ::

    >>> m_per_s = Scale( ("ml_si_m.s-1_ratio",263223643595076551490114979345460778542) )
    <BLANKLINE>
    >>> print( repr(v) )
    Expression(1.5,m/(s))
    >>> print( v.convert(m_per_s) )
    1.5 m.s-1
    
Energy or moment of force
~~~~~~~~~~~~~~~~~~~~~~~~~

The special name joule is defined for the unit of energy in the SI, and the compound name newton-metre is the recommended unit for moment of force. Nevertheless, the systematic unit name kilogram-metre-squared-per-second-squared (kg.m2.s-2) in a valid alternative to both these unit names. 

It is possible to form a compound scale for kg.m2.s-2 and use it to express data ::

    >>> kg = Scale( ('ml_si_kilogram_ratio', 12782167041499057092439851237297548539) )
    >>> m = Scale( ('ml_si_metre_ratio', 17771593641054934856197983478245767638) )
    >>> s = Scale( ('ml_si_second_ratio', 276296348539283398608930897564542275037) )

    >>> kg_mm_ss = kg*m**2/s**2
    >>> print(kg_mm_ss)
    kg.m^2/(s^2)
    >>> w = expr(10.1,kg_mm_ss)
    >>> print( w )
    10.1 kg.m^2/(s^2)

However, the aspect is unspecified and this expression does not distinguish between energy and moment of force. By declaring the aspects ::

    >>> energy = Aspect( ("ml_energy", 12139911566084412692636353460656684046) )
    >>> moment = Aspect( ("ml_force_moment", 313648474034040825357489751369673453388) )
    
and the scales ::

    >>> J = Scale( ("ml_si_joule_ratio",165050666678496469850612022016789737781) )
    >>> N_m = Scale( ("ml_si_N.m_ratio",180123565723874772354088506298557924442) )

it is possible to cast the systematic unit representation to one that is quantity-specific, such as ::

    >>> print( w.cast( ScaleAspect(J,energy) ) )
    10.1 J
    
or ::

    >>> print( w.cast( ScaleAspect(N_m,moment) ) )
    10.1 N m
    
Compound scale dimensions
~~~~~~~~~~~~~~~~~~~~~~~~~

A :class:`~lib.CompoundScale` has a :meth:`dimension<lib.CompoundScale.dimension>` property that returns a :class:`~dimension.CompoundDimension` associated with an expression :: 

    >>> print( kg_mm_ss.dimension )
    { SI(0, 0, 1, 0, 0, 0, 0) : [-2], SI(0, 1, 0, 0, 0, 0, 0) : [2], SI(1, 0, 0, 0, 0, 0, 0) : [1] }

The :class:`~dimension.CompoundDimension` is a collection of :class:`~dimension.Dimension` objects -- one for every scale -- each with an associated exponent. 

A compound dimension can be reduced to a single :class:`~dimension.Dimension`, by combining and simplifying the dimensions and exponents ::

    >>> print( kg_mm_ss.dimension.simplify )
    SI(1, 2, -2, 0, 0, 0, 0)

If a scale is not coherent in the unit system, a factor relating the incoherent unit to the corresponding coherent unit is included. For example, using the unit nanometre, which is not the coherent unit for length in the SI

    >>> nm = Scale( ("ml_si_nm_ratio", 257091757625055920788370123828667027186) )
    >>> kg_nmnm_ss = kg*nm**2/s**2
    >>> print( kg_nmnm_ss.dimension )
    { SI(0, 0, 1, 0, 0, 0, 0) : [-2], 1E-09*SI(0, 1, 0, 0, 0, 0, 0) : [2], SI(1, 0, 0, 0, 0, 0, 0) : [1] }

When this compound unit is simplified, the association of the prefix nano with the metre scale is lost but a resultant prefix value is retained ::
     
    >>> print( kg_nmnm_ss.dimension.simplify )
    1E-18*SI(1, 2, -2, 0, 0, 0, 0)

Compound scale identifiers
~~~~~~~~~~~~~~~~~~~~~~~~~~

A :class:`~lib.CompoundScale` has a :meth:`uid<lib.CompoundScale.uid>` property that returns a :class:`~uid.CompoundUID` associated with an expression ::

    >>> print( kg_mm_ss.uid )
    { ['ml_si_second_ratio', 276296348539283398608930897564542275037] : [-2], ['ml_si_metre_ratio', 17771593641054934856197983478245767638] : [2], ['ml_si_kilogram_ratio', 12782167041499057092439851237297548539] : [1] } 
    
This captures the identifiers of the individual scales and their exponents. :class:`~uid.CompoundUID` objects may be compared for equality.

Ratios involving the same scale
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

One of the difficulties that arises when compound units are represented in terms of their SI dimensions, is the arithmetic cancellation of terms with the same dimension. 

For instance, we may wish to express a horizontal velocity gradient with respect to height (e.g., a rate of change in wind speed with altitude). Suitable units could be metres per second per metre. A compound scale for this can be declared ::

    >>> m = Scale( ('ml_si_metre_ratio', 17771593641054934856197983478245767638) )
    >>> s = Scale( ('ml_si_second_ratio', 276296348539283398608930897564542275037) )

    >>> m_s = m/s
    >>> m_s_m = m_s/m

However, the software recognises that reference is made twice to the *same* metre Scale object, which appears in both the numerator and denominator. The default behaviour is to cancel this common factor ::

    >>> print( m_s_m.uid )
    { ['ml_si_second_ratio', 276296348539283398608930897564542275037] : [-1] } 
    
Nevertheless, a distinction between units of elevation and horizontal length can be made by creating a second instance of the metre Scale. The software recognises that the different objects have distinct roles in the expression, although they are associated with the same M-layer scale ::

    >>> m_height = Scale( ('ml_si_metre_ratio',17771593641054934856197983478245767638) )
    >>> m_s_m = m_s/m_height 
    >>> print( m_s_m.uid )
    { ['ml_si_metre_ratio', 17771593641054934856197983478245767638] : [1, -1], ['ml_si_second_ratio', 276296348539283398608930897564542275037] : [-1] } 
    
The SI metre is now seen to appear in the numerator and denominator of the compound unit. 

Similarly, the :class:`~dimension.CompoundDimension` captures the two exponents associated with length when distinct Scale object are used ::

    >>> print( m_s_m.dimension )
    { SI(0, 1, 0, 0, 0, 0, 0) : [1, -1], SI(0, 0, 1, 0, 0, 0, 0) : [-1] }

This compound dimension can simplified, which cancels references to the metre Scale ::
    
    >>> print( m_s_m.dimension.simplify )
    SI(0, 0, -1, 0, 0, 0, 0)
 
.. note::
 
    The M-layer register does not hold records for compound scales. So, the software works with the compound-scale expressions that encapsulate individual scales. These compound-scale expressions can be matched, term by term, to scales in another expression. This requires the two expressions to have exactly the same arithmetic form.

    Conversion from a compound-scale expression to a single-scale expression is not always possible. The individual scales must belong to the same unit system, so they have dimensions in that system. This information may be used to evaluate the compound-scale dimensions, which may be matched to a corresponding systematic scale.   

Compound scale-aspects 
======================

The functionality described above for scales has also been implemented for scale-aspects. Multiplication, division and exponentiation operations can be used with :class:`~lib.ScaleAspect` objects.  For instance ::

    >>> m = ScaleAspect(
    ...     Scale( ('ml_si_metre_ratio', 17771593641054934856197983478245767638) ),
    ...     Aspect( ('ml_length', 993853592179723568440264076369400241) )
    ...     )
    >>> s = ScaleAspect( 
    ...     Scale( ('ml_si_second_ratio', 276296348539283398608930897564542275037) ),
    ...     Aspect( ('ml_time', 59007067547744628223483093626372886675) )
    ...     )
    >>> print( m/s )
    (m, length)/(s, time)
    >>> print( expr(1.5, m/s ) ) 
    1.5 (m, length)/(s, time)

Units conversion now checks the compatibility of each term's scale and aspect ::

    >>> length = Aspect( ('ml_length', 993853592179723568440264076369400241) )
    >>> foot = ft.to_scale_aspect(length)   
    
    >>> y = expr(1.5, m/s )
    >>> convert(y, foot/s )
    Expression(4.92126,(ft, length)/(s, time))

Note, the earlier declaration of ``ft`` created a :class:`~lib.Scale`, which does not specify an aspect. Mixing of scales and scale-aspects is not supported, so the code above explicitly promotes ``ft`` to a :class:`~lib.ScaleAspect` ``foot``, with aspect length. 